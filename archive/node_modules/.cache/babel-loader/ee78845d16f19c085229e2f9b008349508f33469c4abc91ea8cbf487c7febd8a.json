{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Matrix4, Mesh, BufferGeometry, MathUtils, DataTexture, RGBAFormat, FloatType, BufferAttribute } from \"three\";\nconst _identityMatrix = new Matrix4();\nconst _zeroMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\nconst batchingParsVertex = /* glsl */\n`\n#ifdef BATCHING\n\tattribute float id;\n\tuniform highp sampler2D batchingTexture;\n\tuniform int batchingTextureSize;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( batchingTextureSize ) );\n\t\tfloat y = floor( j / float( batchingTextureSize ) );\n\t\tfloat dx = 1.0 / float( batchingTextureSize );\n\t\tfloat dy = 1.0 / float( batchingTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( batchingTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( batchingTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( batchingTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( batchingTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif\n`;\nconst batchingbaseVertex = /* glsl */\n`\n#ifdef BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( id );\n#endif\n`;\nconst batchingnormalVertex = /* glsl */\n`\n#ifdef BATCHING\n\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n`;\nconst batchingVertex = /* glsl */\n`\n#ifdef BATCHING\n\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n`;\nclass BatchedMesh extends Mesh {\n  constructor(maxGeometryCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {\n    super(new BufferGeometry(), material);\n    __publicField(this, \"_vertexStarts\");\n    __publicField(this, \"_vertexCounts\");\n    __publicField(this, \"_indexStarts\");\n    __publicField(this, \"_indexCounts\");\n    __publicField(this, \"_visibles\");\n    __publicField(this, \"_alives\");\n    __publicField(this, \"_maxGeometryCount\");\n    __publicField(this, \"_maxVertexCount\");\n    __publicField(this, \"_maxIndexCount\");\n    __publicField(this, \"_geometryInitialized\");\n    __publicField(this, \"_geometryCount\");\n    __publicField(this, \"_vertexCount\");\n    __publicField(this, \"_indexCount\");\n    __publicField(this, \"_matrices\");\n    __publicField(this, \"_matricesArray\");\n    __publicField(this, \"_matricesTexture\");\n    __publicField(this, \"_matricesTextureSize\");\n    __publicField(this, \"_customUniforms\");\n    this._vertexStarts = [];\n    this._vertexCounts = [];\n    this._indexStarts = [];\n    this._indexCounts = [];\n    this._visibles = [];\n    this._alives = [];\n    this._maxGeometryCount = maxGeometryCount;\n    this._maxVertexCount = maxVertexCount;\n    this._maxIndexCount = maxIndexCount;\n    this._geometryInitialized = false;\n    this._geometryCount = 0;\n    this._vertexCount = 0;\n    this._indexCount = 0;\n    this._matrices = [];\n    this._matricesArray = null;\n    this._matricesTexture = null;\n    this._matricesTextureSize = null;\n    this.frustumCulled = false;\n    this._customUniforms = {\n      batchingTexture: {\n        value: null\n      },\n      batchingTextureSize: {\n        value: 0\n      }\n    };\n    this._initMatricesTexture();\n    this._initShader();\n  }\n  _initMatricesTexture() {\n    let size = Math.sqrt(this._maxGeometryCount * 4);\n    size = MathUtils.ceilPowerOfTwo(size);\n    size = Math.max(size, 4);\n    const matricesArray = new Float32Array(size * size * 4);\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);\n    this._matricesArray = matricesArray;\n    this._matricesTexture = matricesTexture;\n    this._matricesTextureSize = size;\n    this._customUniforms.batchingTexture.value = this._matricesTexture;\n    this._customUniforms.batchingTextureSize.value = this._matricesTextureSize;\n  }\n  _initShader() {\n    const currentOnBeforeCompile = this.material.onBeforeCompile;\n    const customUniforms = this._customUniforms;\n    this.material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n      parameters.vertexShader = parameters.vertexShader.replace(\"#include <skinning_pars_vertex>\", \"#include <skinning_pars_vertex>\\n\" + batchingParsVertex).replace(\"#include <skinnormal_vertex>\", \"#include <skinnormal_vertex>\\n\" + batchingbaseVertex + batchingnormalVertex).replace(\"#include <skinning_vertex>\", \"#include <skinning_vertex>\\n\" + batchingVertex);\n      for (const uniformName in customUniforms) {\n        parameters.uniforms[uniformName] = customUniforms[uniformName];\n      }\n      currentOnBeforeCompile.call(this, parameters, renderer);\n    };\n    this.material.defines = this.material.defines || {};\n    this.material.defines.BATCHING = false;\n  }\n  getGeometryCount() {\n    return this._geometryCount;\n  }\n  getVertexCount() {\n    return this._vertexCount;\n  }\n  getIndexCount() {\n    return this._indexCount;\n  }\n  applyGeometry(geometry) {\n    var _a;\n    if (this._geometryCount >= this._maxGeometryCount) ;\n    if (this._geometryInitialized === false) {\n      for (const attributeName in geometry.attributes) {\n        const srcAttribute = geometry.getAttribute(attributeName);\n        const {\n          array,\n          itemSize,\n          normalized\n        } = srcAttribute;\n        const dstArray = new array.constructor(this._maxVertexCount * itemSize);\n        const dstAttribute = new srcAttribute.constructor(dstArray, itemSize, normalized);\n        dstAttribute.setUsage(srcAttribute.usage);\n        this.geometry.setAttribute(attributeName, dstAttribute);\n      }\n      if (geometry.getIndex() !== null) {\n        const indexArray = this._maxVertexCount > 65536 ? new Uint32Array(this._maxIndexCount) : new Uint16Array(this._maxIndexCount);\n        this.geometry.setIndex(new BufferAttribute(indexArray, 1));\n      }\n      const idArray = this._maxGeometryCount > 65536 ? new Uint32Array(this._maxVertexCount) : new Uint16Array(this._maxVertexCount);\n      this.geometry.setAttribute(\"id\", new BufferAttribute(idArray, 1));\n      this._geometryInitialized = true;\n    }\n    const hasIndex = this.geometry.getIndex() !== null;\n    const dstIndex = this.geometry.getIndex();\n    const srcIndex = geometry.getIndex();\n    const srcPositionAttribute = geometry.getAttribute(\"position\");\n    this._vertexStarts.push(this._vertexCount);\n    this._vertexCounts.push(srcPositionAttribute.count);\n    if (hasIndex) {\n      this._indexStarts.push(this._indexCount);\n      this._indexCounts.push(srcIndex.count);\n    }\n    this._visibles.push(true);\n    this._alives.push(true);\n    for (const attributeName in geometry.attributes) {\n      const srcAttribute = geometry.getAttribute(attributeName);\n      const dstAttribute = this.geometry.getAttribute(attributeName);\n      dstAttribute.array.set(srcAttribute.array, this._vertexCount * dstAttribute.itemSize);\n      dstAttribute.needsUpdate = true;\n    }\n    if (hasIndex) {\n      for (let i = 0; i < srcIndex.count; i++) {\n        dstIndex.setX(this._indexCount + i, this._vertexCount + srcIndex.getX(i));\n      }\n      this._indexCount += srcIndex.count;\n      dstIndex.needsUpdate = true;\n    }\n    const geometryId = this._geometryCount;\n    this._geometryCount++;\n    const idAttribute = this.geometry.getAttribute(\"id\");\n    for (let i = 0; i < srcPositionAttribute.count; i++) {\n      idAttribute.setX(this._vertexCount + i, geometryId);\n    }\n    idAttribute.needsUpdate = true;\n    this._vertexCount += srcPositionAttribute.count;\n    this._matrices.push(new Matrix4());\n    _identityMatrix.toArray((_a = this._matricesArray) != null ? _a : void 0, geometryId * 16);\n    this._matricesTexture.needsUpdate = true;\n    return geometryId;\n  }\n  deleteGeometry(geometryId) {\n    if (geometryId >= this._alives.length || this._alives[geometryId] === false) {\n      return this;\n    }\n    this._alives[geometryId] = false;\n    _zeroMatrix.toArray(this._matricesArray, geometryId * 16);\n    this._matricesTexture.needsUpdate = true;\n    return this;\n  }\n  optimize() {\n    return this;\n  }\n  setMatrixAt(geometryId, matrix) {\n    if (geometryId >= this._matrices.length || this._alives[geometryId] === false) {\n      return this;\n    }\n    this._matrices[geometryId].copy(matrix);\n    if (this._visibles[geometryId] === true) {\n      matrix.toArray(this._matricesArray, geometryId * 16);\n      this._matricesTexture.needsUpdate = true;\n    }\n    return this;\n  }\n  getMatrixAt(geometryId, matrix) {\n    if (geometryId >= this._matrices.length || this._alives[geometryId] === false) {\n      return matrix;\n    }\n    return matrix.copy(this._matrices[geometryId]);\n  }\n  setVisibleAt(geometryId, visible) {\n    if (geometryId >= this._visibles.length || this._alives[geometryId] === false) {\n      return this;\n    }\n    if (this._visibles[geometryId] === visible) {\n      return this;\n    }\n    if (visible === true) {\n      this._matrices[geometryId].toArray(this._matricesArray, geometryId * 16);\n    } else {\n      _zeroMatrix.toArray(this._matricesArray, geometryId * 16);\n    }\n    this._matricesTexture.needsUpdate = true;\n    this._visibles[geometryId] = visible;\n    return this;\n  }\n  getVisibleAt(geometryId) {\n    if (geometryId >= this._visibles.length || this._alives[geometryId] === false) {\n      return false;\n    }\n    return this._visibles[geometryId];\n  }\n  copy(source) {\n    super.copy(source);\n    return this;\n  }\n  toJSON(meta) {\n    return super.toJSON(meta);\n  }\n  dispose() {\n    var _a;\n    this.geometry.dispose();\n    (_a = this._matricesTexture) == null ? void 0 : _a.dispose();\n    this._matricesTexture = null;\n    return this;\n  }\n  // @ts-ignore\n  onBeforeRender() {\n    if (this.material.defines) {\n      this.material.defines.BATCHING = true;\n    }\n  }\n  // @ts-ignore\n  onAfterRender() {\n    if (this.material.defines) {\n      this.material.defines.BATCHING = false;\n    }\n  }\n}\nexport { BatchedMesh };","map":{"version":3,"names":["_identityMatrix","Matrix4","_zeroMatrix","set","batchingParsVertex","batchingbaseVertex","batchingnormalVertex","batchingVertex","BatchedMesh","Mesh","constructor","maxGeometryCount","maxVertexCount","maxIndexCount","material","BufferGeometry","__publicField","_vertexStarts","_vertexCounts","_indexStarts","_indexCounts","_visibles","_alives","_maxGeometryCount","_maxVertexCount","_maxIndexCount","_geometryInitialized","_geometryCount","_vertexCount","_indexCount","_matrices","_matricesArray","_matricesTexture","_matricesTextureSize","frustumCulled","_customUniforms","batchingTexture","value","batchingTextureSize","_initMatricesTexture","_initShader","size","Math","sqrt","MathUtils","ceilPowerOfTwo","max","matricesArray","Float32Array","matricesTexture","DataTexture","RGBAFormat","FloatType","currentOnBeforeCompile","onBeforeCompile","customUniforms","parameters","renderer","vertexShader","replace","uniformName","uniforms","call","defines","BATCHING","getGeometryCount","getVertexCount","getIndexCount","applyGeometry","geometry","attributeName","attributes","srcAttribute","getAttribute","array","itemSize","normalized","dstArray","dstAttribute","setUsage","usage","setAttribute","getIndex","indexArray","Uint32Array","Uint16Array","setIndex","BufferAttribute","idArray","hasIndex","dstIndex","srcIndex","srcPositionAttribute","push","count","needsUpdate","i","setX","getX","geometryId","idAttribute","toArray","_a","deleteGeometry","length","optimize","setMatrixAt","matrix","copy","getMatrixAt","setVisibleAt","visible","getVisibleAt","source","toJSON","meta","dispose","onBeforeRender","onAfterRender"],"sources":["/Users/chengzixin/Documents/ITP/Second Year/2023 Fall/Visual Journalism/nypd-robot/prototype/node_modules/src/objects/BatchedMesh.ts"],"sourcesContent":["import {\n  Matrix4,\n  Mesh,\n  BufferGeometry,\n  Material,\n  DataTexture,\n  IUniform,\n  MathUtils,\n  RGBAFormat,\n  FloatType,\n  BufferAttribute,\n} from 'three'\n\nconst _identityMatrix = new Matrix4()\nconst _zeroMatrix = new Matrix4().set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)\n\n// Custom shaders\nconst batchingParsVertex = /* glsl */ `\n#ifdef BATCHING\n\tattribute float id;\n\tuniform highp sampler2D batchingTexture;\n\tuniform int batchingTextureSize;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( batchingTextureSize ) );\n\t\tfloat y = floor( j / float( batchingTextureSize ) );\n\t\tfloat dx = 1.0 / float( batchingTextureSize );\n\t\tfloat dy = 1.0 / float( batchingTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( batchingTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( batchingTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( batchingTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( batchingTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif\n`\n\nconst batchingbaseVertex = /* glsl */ `\n#ifdef BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( id );\n#endif\n`\n\nconst batchingnormalVertex = /* glsl */ `\n#ifdef BATCHING\n\tobjectNormal = vec4( batchingMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( batchingMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif\n`\n\nconst batchingVertex = /* glsl */ `\n#ifdef BATCHING\n\ttransformed = ( batchingMatrix * vec4( transformed, 1.0 ) ).xyz;\n#endif\n`\n\n// @TODO: SkinnedMesh support?\n// @TODO: Future work if needed. Move into the core. Can be optimized more with WEBGL_multi_draw.\n\nclass BatchedMesh extends Mesh<BufferGeometry, Material> {\n  _vertexStarts: number[]\n  _vertexCounts: number[]\n  _indexStarts: number[]\n  _indexCounts: number[]\n  _visibles: boolean[]\n  _alives: boolean[]\n  _maxGeometryCount: number\n  _maxVertexCount: number\n  _maxIndexCount: number\n  _geometryInitialized: boolean\n  _geometryCount: number\n  _vertexCount: number\n  _indexCount: number\n  _matrices: Matrix4[]\n  _matricesArray: Float32Array | null\n  _matricesTexture: DataTexture | null\n  _matricesTextureSize: number | null\n  _customUniforms: Record<string, IUniform>\n\n  constructor(\n    maxGeometryCount: number,\n    maxVertexCount: number,\n    maxIndexCount = maxVertexCount * 2,\n    material?: Material,\n  ) {\n    super(new BufferGeometry(), material)\n\n    this._vertexStarts = []\n    this._vertexCounts = []\n    this._indexStarts = []\n    this._indexCounts = []\n\n    this._visibles = []\n    this._alives = []\n\n    this._maxGeometryCount = maxGeometryCount\n    this._maxVertexCount = maxVertexCount\n    this._maxIndexCount = maxIndexCount\n\n    this._geometryInitialized = false\n    this._geometryCount = 0\n    this._vertexCount = 0\n    this._indexCount = 0\n\n    // Local matrix per geometry by using data texture\n    // @TODO: Support uniform parameter per geometry\n\n    this._matrices = []\n    this._matricesArray = null\n    this._matricesTexture = null\n    this._matricesTextureSize = null\n\n    // @TODO: Calculate the entire binding box and make frustumCulled true\n    this.frustumCulled = false\n\n    this._customUniforms = {\n      batchingTexture: { value: null },\n      batchingTextureSize: { value: 0 },\n    }\n\n    this._initMatricesTexture()\n    this._initShader()\n  }\n\n  _initMatricesTexture() {\n    // layout (1 matrix = 4 pixels)\n    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n    //  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)\n    //       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)\n    //       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)\n    //       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)\n\n    let size = Math.sqrt(this._maxGeometryCount * 4) // 4 pixels needed for 1 matrix\n    size = MathUtils.ceilPowerOfTwo(size)\n    size = Math.max(size, 4)\n\n    const matricesArray = new Float32Array(size * size * 4) // 4 floats per RGBA pixel\n    const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType)\n\n    this._matricesArray = matricesArray\n    this._matricesTexture = matricesTexture\n    this._matricesTextureSize = size\n\n    this._customUniforms.batchingTexture.value = this._matricesTexture\n    this._customUniforms.batchingTextureSize.value = this._matricesTextureSize\n  }\n\n  _initShader() {\n    const currentOnBeforeCompile = this.material.onBeforeCompile\n    const customUniforms = this._customUniforms\n\n    this.material.onBeforeCompile = function onBeforeCompile(parameters, renderer) {\n      // Is this replacement stable across any materials?\n      parameters.vertexShader = parameters.vertexShader\n        .replace('#include <skinning_pars_vertex>', '#include <skinning_pars_vertex>\\n' + batchingParsVertex)\n        .replace(\n          '#include <skinnormal_vertex>',\n          '#include <skinnormal_vertex>\\n' + batchingbaseVertex + batchingnormalVertex,\n        )\n        .replace('#include <skinning_vertex>', '#include <skinning_vertex>\\n' + batchingVertex)\n\n      for (const uniformName in customUniforms) {\n        parameters.uniforms[uniformName] = customUniforms[uniformName]\n      }\n\n      currentOnBeforeCompile.call(this, parameters, renderer)\n    }\n\n    this.material.defines = this.material.defines || {}\n    this.material.defines.BATCHING = false\n  }\n\n  getGeometryCount() {\n    return this._geometryCount\n  }\n\n  getVertexCount() {\n    return this._vertexCount\n  }\n\n  getIndexCount() {\n    return this._indexCount\n  }\n\n  applyGeometry(geometry: BufferGeometry) {\n    // @TODO: geometry.groups support?\n    // @TODO: geometry.drawRange support?\n    // @TODO: geometry.mortphAttributes support?\n\n    if (this._geometryCount >= this._maxGeometryCount) {\n      // @TODO: Error handling\n    }\n\n    if (this._geometryInitialized === false) {\n      for (const attributeName in geometry.attributes) {\n        const srcAttribute = geometry.getAttribute(attributeName)\n        const { array, itemSize, normalized } = srcAttribute\n\n        const dstArray = new (array.constructor as Float32ArrayConstructor)(this._maxVertexCount * itemSize)\n        const dstAttribute = new (srcAttribute.constructor as any)(dstArray, itemSize, normalized) as BufferAttribute\n\n        // TODO: add usage in @types/three\n        // @ts-ignore\n        dstAttribute.setUsage(srcAttribute.usage)\n\n        this.geometry.setAttribute(attributeName, dstAttribute)\n      }\n\n      if (geometry.getIndex() !== null) {\n        const indexArray =\n          this._maxVertexCount > 65536 ? new Uint32Array(this._maxIndexCount) : new Uint16Array(this._maxIndexCount)\n\n        this.geometry.setIndex(new BufferAttribute(indexArray, 1))\n      }\n\n      const idArray =\n        this._maxGeometryCount > 65536 ? new Uint32Array(this._maxVertexCount) : new Uint16Array(this._maxVertexCount)\n      // @TODO: What if attribute name 'id' is already used?\n      this.geometry.setAttribute('id', new BufferAttribute(idArray, 1))\n\n      this._geometryInitialized = true\n    } else {\n      // @TODO: Check if geometry has the same attributes set\n    }\n\n    const hasIndex = this.geometry.getIndex() !== null\n    const dstIndex = this.geometry.getIndex()\n    const srcIndex = geometry.getIndex()\n\n    // Assuming geometry has position attribute\n    const srcPositionAttribute = geometry.getAttribute('position')\n\n    this._vertexStarts.push(this._vertexCount)\n    this._vertexCounts.push(srcPositionAttribute.count)\n\n    if (hasIndex) {\n      this._indexStarts.push(this._indexCount)\n      this._indexCounts.push(srcIndex!.count)\n    }\n\n    this._visibles.push(true)\n    this._alives.push(true)\n\n    // @TODO: Error handling if exceeding maxVertexCount or maxIndexCount\n\n    for (const attributeName in geometry.attributes) {\n      const srcAttribute = geometry.getAttribute(attributeName)\n      const dstAttribute = this.geometry.getAttribute(attributeName)\n      ;(dstAttribute.array as Float32Array).set(srcAttribute.array, this._vertexCount * dstAttribute.itemSize)\n      dstAttribute.needsUpdate = true\n    }\n\n    if (hasIndex) {\n      for (let i = 0; i < srcIndex!.count; i++) {\n        dstIndex!.setX(this._indexCount + i, this._vertexCount + srcIndex!.getX(i))\n      }\n\n      this._indexCount += srcIndex!.count\n      dstIndex!.needsUpdate = true\n    }\n\n    const geometryId = this._geometryCount\n    this._geometryCount++\n\n    const idAttribute = this.geometry.getAttribute('id')\n\n    for (let i = 0; i < srcPositionAttribute.count; i++) {\n      idAttribute.setX(this._vertexCount + i, geometryId)\n    }\n\n    idAttribute.needsUpdate = true\n\n    this._vertexCount += srcPositionAttribute.count\n\n    this._matrices.push(new Matrix4())\n    _identityMatrix.toArray(this._matricesArray ?? undefined, geometryId * 16)\n    this._matricesTexture!.needsUpdate = true\n\n    return geometryId\n  }\n\n  deleteGeometry(geometryId: number) {\n    if (geometryId >= this._alives.length || this._alives[geometryId] === false) {\n      return this\n    }\n\n    this._alives[geometryId] = false\n    _zeroMatrix.toArray(this._matricesArray!, geometryId * 16)\n    this._matricesTexture!.needsUpdate = true\n\n    // User needs to call optimize() to pack the data.\n\n    return this\n  }\n\n  optimize() {\n    // @TODO: Implement\n\n    return this\n  }\n\n  setMatrixAt(geometryId: number, matrix: Matrix4) {\n    // @TODO: Map geometryId to index of the arrays because\n    //        optimize() can make geometryId mismatch the index\n\n    if (geometryId >= this._matrices.length || this._alives[geometryId] === false) {\n      return this\n    }\n\n    this._matrices[geometryId].copy(matrix)\n\n    if (this._visibles[geometryId] === true) {\n      matrix.toArray(this._matricesArray!, geometryId * 16)\n      this._matricesTexture!.needsUpdate = true\n    }\n\n    return this\n  }\n\n  getMatrixAt(geometryId: number, matrix: Matrix4) {\n    if (geometryId >= this._matrices.length || this._alives[geometryId] === false) {\n      return matrix\n    }\n\n    return matrix.copy(this._matrices[geometryId])\n  }\n\n  setVisibleAt(geometryId: number, visible: boolean) {\n    if (geometryId >= this._visibles.length || this._alives[geometryId] === false) {\n      return this\n    }\n\n    if (this._visibles[geometryId] === visible) {\n      return this\n    }\n\n    if (visible === true) {\n      this._matrices[geometryId].toArray(this._matricesArray!, geometryId * 16)\n    } else {\n      _zeroMatrix.toArray(this._matricesArray!, geometryId * 16)\n    }\n\n    this._matricesTexture!.needsUpdate = true\n    this._visibles[geometryId] = visible\n    return this\n  }\n\n  getVisibleAt(geometryId: number) {\n    if (geometryId >= this._visibles.length || this._alives[geometryId] === false) {\n      return false\n    }\n\n    return this._visibles[geometryId]\n  }\n\n  copy(source: BatchedMesh) {\n    // @ts-ignore\n    super.copy(source)\n\n    // @TODO: Implement\n\n    return this\n  }\n\n  toJSON(meta: any) {\n    // @TODO: Implement\n\n    return super.toJSON(meta)\n  }\n\n  dispose() {\n    // Assuming the geometry is not shared with other meshes\n    this.geometry.dispose()\n\n    this._matricesTexture?.dispose()\n    this._matricesTexture = null\n\n    return this\n  }\n\n  // @ts-ignore\n  onBeforeRender() {\n    if (this.material.defines) {\n      this.material.defines.BATCHING = true\n    }\n\n    // @TODO: Implement frustum culling for each geometry\n  }\n\n  // @ts-ignore\n  onAfterRender() {\n    if (this.material.defines) {\n      this.material.defines.BATCHING = false\n    }\n  }\n}\n\nexport { BatchedMesh }\n"],"mappings":";;;;;;;;;;;;AAaA,MAAMA,eAAA,GAAkB,IAAIC,OAAA;AAC5B,MAAMC,WAAA,GAAc,IAAID,OAAA,CAAQ,EAAEE,GAAA,CAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAGpF,MAAMC,kBAAA;AAAgC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBtC,MAAMC,kBAAA;AAAgC;AAAA;AAAA;AAAA;AAAA;AAMtC,MAAMC,oBAAA;AAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASxC,MAAMC,cAAA;AAA4B;AAAA;AAAA;AAAA;AAAA;AASlC,MAAMC,WAAA,SAAoBC,IAAA,CAA+B;EAoBvDC,YACEC,gBAAA,EACAC,cAAA,EACAC,aAAA,GAAgBD,cAAA,GAAiB,GACjCE,QAAA,EACA;IACM,UAAIC,cAAA,IAAkBD,QAAQ;IAzBtCE,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IACAA,aAAA;IAUE,KAAKC,aAAA,GAAgB;IACrB,KAAKC,aAAA,GAAgB;IACrB,KAAKC,YAAA,GAAe;IACpB,KAAKC,YAAA,GAAe;IAEpB,KAAKC,SAAA,GAAY;IACjB,KAAKC,OAAA,GAAU;IAEf,KAAKC,iBAAA,GAAoBZ,gBAAA;IACzB,KAAKa,eAAA,GAAkBZ,cAAA;IACvB,KAAKa,cAAA,GAAiBZ,aAAA;IAEtB,KAAKa,oBAAA,GAAuB;IAC5B,KAAKC,cAAA,GAAiB;IACtB,KAAKC,YAAA,GAAe;IACpB,KAAKC,WAAA,GAAc;IAKnB,KAAKC,SAAA,GAAY;IACjB,KAAKC,cAAA,GAAiB;IACtB,KAAKC,gBAAA,GAAmB;IACxB,KAAKC,oBAAA,GAAuB;IAG5B,KAAKC,aAAA,GAAgB;IAErB,KAAKC,eAAA,GAAkB;MACrBC,eAAA,EAAiB;QAAEC,KAAA,EAAO;MAAK;MAC/BC,mBAAA,EAAqB;QAAED,KAAA,EAAO;MAAE;IAAA;IAGlC,KAAKE,oBAAA,CAAqB;IAC1B,KAAKC,WAAA,CAAY;EACnB;EAEAD,qBAAA,EAAuB;IAQrB,IAAIE,IAAA,GAAOC,IAAA,CAAKC,IAAA,CAAK,KAAKpB,iBAAA,GAAoB,CAAC;IACxCkB,IAAA,GAAAG,SAAA,CAAUC,cAAA,CAAeJ,IAAI;IAC7BA,IAAA,GAAAC,IAAA,CAAKI,GAAA,CAAIL,IAAA,EAAM,CAAC;IAEvB,MAAMM,aAAA,GAAgB,IAAIC,YAAA,CAAaP,IAAA,GAAOA,IAAA,GAAO,CAAC;IACtD,MAAMQ,eAAA,GAAkB,IAAIC,WAAA,CAAYH,aAAA,EAAeN,IAAA,EAAMA,IAAA,EAAMU,UAAA,EAAYC,SAAS;IAExF,KAAKrB,cAAA,GAAiBgB,aAAA;IACtB,KAAKf,gBAAA,GAAmBiB,eAAA;IACxB,KAAKhB,oBAAA,GAAuBQ,IAAA;IAEvB,KAAAN,eAAA,CAAgBC,eAAA,CAAgBC,KAAA,GAAQ,KAAKL,gBAAA;IAC7C,KAAAG,eAAA,CAAgBG,mBAAA,CAAoBD,KAAA,GAAQ,KAAKJ,oBAAA;EACxD;EAEAO,YAAA,EAAc;IACN,MAAAa,sBAAA,GAAyB,KAAKvC,QAAA,CAASwC,eAAA;IAC7C,MAAMC,cAAA,GAAiB,KAAKpB,eAAA;IAE5B,KAAKrB,QAAA,CAASwC,eAAA,GAAkB,SAASA,gBAAgBE,UAAA,EAAYC,QAAA,EAAU;MAE7ED,UAAA,CAAWE,YAAA,GAAeF,UAAA,CAAWE,YAAA,CAClCC,OAAA,CAAQ,mCAAmC,sCAAsCvD,kBAAkB,EACnGuD,OAAA,CACC,gCACA,mCAAmCtD,kBAAA,GAAqBC,oBAEzD,EAAAqD,OAAA,CAAQ,8BAA8B,iCAAiCpD,cAAc;MAExF,WAAWqD,WAAA,IAAeL,cAAA,EAAgB;QACxCC,UAAA,CAAWK,QAAA,CAASD,WAAW,IAAIL,cAAA,CAAeK,WAAW;MAC/D;MAEuBP,sBAAA,CAAAS,IAAA,CAAK,MAAMN,UAAA,EAAYC,QAAQ;IAAA;IAGxD,KAAK3C,QAAA,CAASiD,OAAA,GAAU,KAAKjD,QAAA,CAASiD,OAAA,IAAW;IAC5C,KAAAjD,QAAA,CAASiD,OAAA,CAAQC,QAAA,GAAW;EACnC;EAEAC,iBAAA,EAAmB;IACjB,OAAO,KAAKtC,cAAA;EACd;EAEAuC,eAAA,EAAiB;IACf,OAAO,KAAKtC,YAAA;EACd;EAEAuC,cAAA,EAAgB;IACd,OAAO,KAAKtC,WAAA;EACd;EAEAuC,cAAcC,QAAA,EAA0B;;IAKlC,SAAK1C,cAAA,IAAkB,KAAKJ,iBAAA,EAAmB;IAI/C,SAAKG,oBAAA,KAAyB,OAAO;MAC5B,WAAA4C,aAAA,IAAiBD,QAAA,CAASE,UAAA,EAAY;QACzC,MAAAC,YAAA,GAAeH,QAAA,CAASI,YAAA,CAAaH,aAAa;QACxD,MAAM;UAAEI,KAAA;UAAOC,QAAA;UAAUC;QAAA,IAAeJ,YAAA;QAExC,MAAMK,QAAA,GAAW,IAAKH,KAAA,CAAMhE,WAAA,CAAwC,KAAKc,eAAA,GAAkBmD,QAAQ;QACnG,MAAMG,YAAA,GAAe,IAAKN,YAAA,CAAa9D,WAAA,CAAoBmE,QAAA,EAAUF,QAAA,EAAUC,UAAU;QAI5EE,YAAA,CAAAC,QAAA,CAASP,YAAA,CAAaQ,KAAK;QAEnC,KAAAX,QAAA,CAASY,YAAA,CAAaX,aAAA,EAAeQ,YAAY;MACxD;MAEI,IAAAT,QAAA,CAASa,QAAA,CAAS,MAAM,MAAM;QAChC,MAAMC,UAAA,GACJ,KAAK3D,eAAA,GAAkB,QAAQ,IAAI4D,WAAA,CAAY,KAAK3D,cAAc,IAAI,IAAI4D,WAAA,CAAY,KAAK5D,cAAc;QAE3G,KAAK4C,QAAA,CAASiB,QAAA,CAAS,IAAIC,eAAA,CAAgBJ,UAAA,EAAY,CAAC,CAAC;MAC3D;MAEA,MAAMK,OAAA,GACJ,KAAKjE,iBAAA,GAAoB,QAAQ,IAAI6D,WAAA,CAAY,KAAK5D,eAAe,IAAI,IAAI6D,WAAA,CAAY,KAAK7D,eAAe;MAE/G,KAAK6C,QAAA,CAASY,YAAA,CAAa,MAAM,IAAIM,eAAA,CAAgBC,OAAA,EAAS,CAAC,CAAC;MAEhE,KAAK9D,oBAAA,GAAuB;IAG9B;IAEA,MAAM+D,QAAA,GAAW,KAAKpB,QAAA,CAASa,QAAA,OAAe;IACxC,MAAAQ,QAAA,GAAW,KAAKrB,QAAA,CAASa,QAAA,CAAS;IAClC,MAAAS,QAAA,GAAWtB,QAAA,CAASa,QAAA;IAGpB,MAAAU,oBAAA,GAAuBvB,QAAA,CAASI,YAAA,CAAa,UAAU;IAExD,KAAAxD,aAAA,CAAc4E,IAAA,CAAK,KAAKjE,YAAY;IACpC,KAAAV,aAAA,CAAc2E,IAAA,CAAKD,oBAAA,CAAqBE,KAAK;IAElD,IAAIL,QAAA,EAAU;MACP,KAAAtE,YAAA,CAAa0E,IAAA,CAAK,KAAKhE,WAAW;MAClC,KAAAT,YAAA,CAAayE,IAAA,CAAKF,QAAA,CAAUG,KAAK;IACxC;IAEK,KAAAzE,SAAA,CAAUwE,IAAA,CAAK,IAAI;IACnB,KAAAvE,OAAA,CAAQuE,IAAA,CAAK,IAAI;IAIX,WAAAvB,aAAA,IAAiBD,QAAA,CAASE,UAAA,EAAY;MACzC,MAAAC,YAAA,GAAeH,QAAA,CAASI,YAAA,CAAaH,aAAa;MACxD,MAAMQ,YAAA,GAAe,KAAKT,QAAA,CAASI,YAAA,CAAaH,aAAa;MAC3DQ,YAAA,CAAaJ,KAAA,CAAuBvE,GAAA,CAAIqE,YAAA,CAAaE,KAAA,EAAO,KAAK9C,YAAA,GAAekD,YAAA,CAAaH,QAAQ;MACvGG,YAAA,CAAaiB,WAAA,GAAc;IAC7B;IAEA,IAAIN,QAAA,EAAU;MACZ,SAASO,CAAA,GAAI,GAAGA,CAAA,GAAIL,QAAA,CAAUG,KAAA,EAAOE,CAAA,IAAK;QAC9BN,QAAA,CAAAO,IAAA,CAAK,KAAKpE,WAAA,GAAcmE,CAAA,EAAG,KAAKpE,YAAA,GAAe+D,QAAA,CAAUO,IAAA,CAAKF,CAAC,CAAC;MAC5E;MAEA,KAAKnE,WAAA,IAAe8D,QAAA,CAAUG,KAAA;MAC9BJ,QAAA,CAAUK,WAAA,GAAc;IAC1B;IAEA,MAAMI,UAAA,GAAa,KAAKxE,cAAA;IACnB,KAAAA,cAAA;IAEL,MAAMyE,WAAA,GAAc,KAAK/B,QAAA,CAASI,YAAA,CAAa,IAAI;IAEnD,SAASuB,CAAA,GAAI,GAAGA,CAAA,GAAIJ,oBAAA,CAAqBE,KAAA,EAAOE,CAAA,IAAK;MACnDI,WAAA,CAAYH,IAAA,CAAK,KAAKrE,YAAA,GAAeoE,CAAA,EAAGG,UAAU;IACpD;IAEAC,WAAA,CAAYL,WAAA,GAAc;IAE1B,KAAKnE,YAAA,IAAgBgE,oBAAA,CAAqBE,KAAA;IAE1C,KAAKhE,SAAA,CAAU+D,IAAA,CAAK,IAAI5F,OAAA,CAAS;IACjCD,eAAA,CAAgBqG,OAAA,EAAQC,EAAA,QAAKvE,cAAA,KAAL,OAAAuE,EAAA,GAAuB,QAAWH,UAAA,GAAa,EAAE;IACzE,KAAKnE,gBAAA,CAAkB+D,WAAA,GAAc;IAE9B,OAAAI,UAAA;EACT;EAEAI,eAAeJ,UAAA,EAAoB;IAC7B,IAAAA,UAAA,IAAc,KAAK7E,OAAA,CAAQkF,MAAA,IAAU,KAAKlF,OAAA,CAAQ6E,UAAU,MAAM,OAAO;MACpE;IACT;IAEK,KAAA7E,OAAA,CAAQ6E,UAAU,IAAI;IAC3BjG,WAAA,CAAYmG,OAAA,CAAQ,KAAKtE,cAAA,EAAiBoE,UAAA,GAAa,EAAE;IACzD,KAAKnE,gBAAA,CAAkB+D,WAAA,GAAc;IAI9B;EACT;EAEAU,SAAA,EAAW;IAGF;EACT;EAEAC,YAAYP,UAAA,EAAoBQ,MAAA,EAAiB;IAI3C,IAAAR,UAAA,IAAc,KAAKrE,SAAA,CAAU0E,MAAA,IAAU,KAAKlF,OAAA,CAAQ6E,UAAU,MAAM,OAAO;MACtE;IACT;IAEA,KAAKrE,SAAA,CAAUqE,UAAU,EAAES,IAAA,CAAKD,MAAM;IAEtC,IAAI,KAAKtF,SAAA,CAAU8E,UAAU,MAAM,MAAM;MACvCQ,MAAA,CAAON,OAAA,CAAQ,KAAKtE,cAAA,EAAiBoE,UAAA,GAAa,EAAE;MACpD,KAAKnE,gBAAA,CAAkB+D,WAAA,GAAc;IACvC;IAEO;EACT;EAEAc,YAAYV,UAAA,EAAoBQ,MAAA,EAAiB;IAC3C,IAAAR,UAAA,IAAc,KAAKrE,SAAA,CAAU0E,MAAA,IAAU,KAAKlF,OAAA,CAAQ6E,UAAU,MAAM,OAAO;MACtE,OAAAQ,MAAA;IACT;IAEA,OAAOA,MAAA,CAAOC,IAAA,CAAK,KAAK9E,SAAA,CAAUqE,UAAU,CAAC;EAC/C;EAEAW,aAAaX,UAAA,EAAoBY,OAAA,EAAkB;IAC7C,IAAAZ,UAAA,IAAc,KAAK9E,SAAA,CAAUmF,MAAA,IAAU,KAAKlF,OAAA,CAAQ6E,UAAU,MAAM,OAAO;MACtE;IACT;IAEA,IAAI,KAAK9E,SAAA,CAAU8E,UAAU,MAAMY,OAAA,EAAS;MACnC;IACT;IAEA,IAAIA,OAAA,KAAY,MAAM;MACpB,KAAKjF,SAAA,CAAUqE,UAAU,EAAEE,OAAA,CAAQ,KAAKtE,cAAA,EAAiBoE,UAAA,GAAa,EAAE;IAAA,OACnE;MACLjG,WAAA,CAAYmG,OAAA,CAAQ,KAAKtE,cAAA,EAAiBoE,UAAA,GAAa,EAAE;IAC3D;IAEA,KAAKnE,gBAAA,CAAkB+D,WAAA,GAAc;IAChC,KAAA1E,SAAA,CAAU8E,UAAU,IAAIY,OAAA;IACtB;EACT;EAEAC,aAAab,UAAA,EAAoB;IAC3B,IAAAA,UAAA,IAAc,KAAK9E,SAAA,CAAUmF,MAAA,IAAU,KAAKlF,OAAA,CAAQ6E,UAAU,MAAM,OAAO;MACtE;IACT;IAEO,YAAK9E,SAAA,CAAU8E,UAAU;EAClC;EAEAS,KAAKK,MAAA,EAAqB;IAExB,MAAML,IAAA,CAAKK,MAAM;IAIV;EACT;EAEAC,OAAOC,IAAA,EAAW;IAGT,aAAMD,MAAA,CAAOC,IAAI;EAC1B;EAEAC,QAAA,EAAU;;IAER,KAAK/C,QAAA,CAAS+C,OAAA;IAEd,CAAAd,EAAA,QAAKtE,gBAAA,KAAL,gBAAAsE,EAAA,CAAuBc,OAAA;IACvB,KAAKpF,gBAAA,GAAmB;IAEjB;EACT;EAAA;EAGAqF,eAAA,EAAiB;IACX,SAAKvG,QAAA,CAASiD,OAAA,EAAS;MACpB,KAAAjD,QAAA,CAASiD,OAAA,CAAQC,QAAA,GAAW;IACnC;EAGF;EAAA;EAGAsD,cAAA,EAAgB;IACV,SAAKxG,QAAA,CAASiD,OAAA,EAAS;MACpB,KAAAjD,QAAA,CAASiD,OAAA,CAAQC,QAAA,GAAW;IACnC;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}