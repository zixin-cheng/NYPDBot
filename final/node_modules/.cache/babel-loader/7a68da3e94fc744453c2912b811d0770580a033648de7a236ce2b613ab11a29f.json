{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Mesh, SkinnedMesh } from \"three\";\nclass STLExporter {\n  constructor() {\n    __publicField(this, \"binary\");\n    __publicField(this, \"output\");\n    __publicField(this, \"offset\");\n    __publicField(this, \"objects\");\n    __publicField(this, \"triangles\");\n    __publicField(this, \"vA\");\n    __publicField(this, \"vB\");\n    __publicField(this, \"vC\");\n    __publicField(this, \"cb\");\n    __publicField(this, \"ab\");\n    __publicField(this, \"normal\");\n    this.binary = false;\n    this.output = \"\";\n    this.offset = 80;\n    this.objects = [];\n    this.triangles = 0;\n    this.vA = new Vector3();\n    this.vB = new Vector3();\n    this.vC = new Vector3();\n    this.cb = new Vector3();\n    this.ab = new Vector3();\n    this.normal = new Vector3();\n  }\n  parse(scene, options) {\n    this.binary = options.binary !== void 0 ? options.binary : false;\n    scene.traverse(object => {\n      if (object instanceof Mesh && object.isMesh) {\n        const geometry = object.geometry;\n        if (!geometry.isBufferGeometry) {\n          throw new Error(\"THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.\");\n        }\n        const index = geometry.index;\n        const positionAttribute = geometry.getAttribute(\"position\");\n        this.triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n        this.objects.push({\n          object3d: object,\n          geometry\n        });\n      }\n    });\n    if (this.binary) {\n      const bufferLength = this.triangles * 2 + this.triangles * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      this.output = new DataView(arrayBuffer);\n      this.output.setUint32(this.offset, this.triangles, true);\n      this.offset += 4;\n    } else {\n      this.output = \"\";\n      this.output += \"solid exported\\n\";\n    }\n    for (let i = 0, il = this.objects.length; i < il; i++) {\n      const object = this.objects[i].object3d;\n      const geometry = this.objects[i].geometry;\n      const index = geometry.index;\n      const positionAttribute = geometry.getAttribute(\"position\");\n      if (object instanceof SkinnedMesh) {\n        if (index !== null) {\n          for (let j = 0; j < index.count; j += 3) {\n            const a = index.getX(j + 0);\n            const b = index.getX(j + 1);\n            const c = index.getX(j + 2);\n            this.writeFace(a, b, c, positionAttribute, object);\n          }\n        } else {\n          for (let j = 0; j < positionAttribute.count; j += 3) {\n            const a = j + 0;\n            const b = j + 1;\n            const c = j + 2;\n            this.writeFace(a, b, c, positionAttribute, object);\n          }\n        }\n      }\n    }\n    if (!this.binary) {\n      this.output += \"endsolid exported\\n\";\n    }\n    return this.output;\n  }\n  writeFace(a, b, c, positionAttribute, object) {\n    this.vA.fromBufferAttribute(positionAttribute, a);\n    this.vB.fromBufferAttribute(positionAttribute, b);\n    this.vC.fromBufferAttribute(positionAttribute, c);\n    if (object.isSkinnedMesh) {\n      object.boneTransform(a, this.vA);\n      object.boneTransform(b, this.vB);\n      object.boneTransform(c, this.vC);\n    }\n    this.vA.applyMatrix4(object.matrixWorld);\n    this.vB.applyMatrix4(object.matrixWorld);\n    this.vC.applyMatrix4(object.matrixWorld);\n    this.writeNormal(this.vA, this.vB, this.vC);\n    this.writeVertex(this.vA);\n    this.writeVertex(this.vB);\n    this.writeVertex(this.vC);\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setUint16(this.offset, 0, true);\n      this.offset += 2;\n    } else {\n      this.output += \"\t\tendloop\\n\";\n      this.output += \"\tendfacet\\n\";\n    }\n  }\n  writeNormal(vA, vB, vC) {\n    this.cb.subVectors(vC, vB);\n    this.ab.subVectors(vA, vB);\n    this.cb.cross(this.ab).normalize();\n    this.normal.copy(this.cb).normalize();\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, this.normal.x, true);\n      this.offset += 4;\n      this.output.setFloat32(this.offset, this.normal.y, true);\n      this.offset += 4;\n      this.output.setFloat32(this.offset, this.normal.z, true);\n      this.offset += 4;\n    } else {\n      this.output += `\tfacet normal ${this.normal.x} ${this.normal.y} ${this.normal.z}\n`;\n      this.output += \"\t\touter loop\\n\";\n    }\n  }\n  writeVertex(vertex) {\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, vertex.x, true);\n      this.offset += 4;\n      this.output.setFloat32(this.offset, vertex.y, true);\n      this.offset += 4;\n      this.output.setFloat32(this.offset, vertex.z, true);\n      this.offset += 4;\n    } else {\n      this.output += `\t\t\tvertex vertex.x vertex.y vertex.z\n`;\n    }\n  }\n}\nexport { STLExporter };","map":{"version":3,"names":["STLExporter","constructor","__publicField","binary","output","offset","objects","triangles","vA","Vector3","vB","vC","cb","ab","normal","parse","scene","options","traverse","object","Mesh","isMesh","geometry","isBufferGeometry","Error","index","positionAttribute","getAttribute","count","push","object3d","bufferLength","arrayBuffer","ArrayBuffer","DataView","setUint32","i","il","length","SkinnedMesh","j","a","getX","b","c","writeFace","fromBufferAttribute","isSkinnedMesh","boneTransform","applyMatrix4","matrixWorld","writeNormal","writeVertex","setUint16","subVectors","cross","normalize","copy","setFloat32","x","y","z","vertex"],"sources":["/Users/chengzixin/Documents/ITP/Second Year/2023 Fall/Visual Journalism/NYPDBot-main/node_modules/src/exporters/STLExporter.ts"],"sourcesContent":["import { BufferAttribute, InterleavedBufferAttribute, Mesh, Object3D, PlaneGeometry, SkinnedMesh, Vector3 } from 'three'\n\n/**\n * Usage:\n *  const exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  const data = exporter.parse( mesh, { binary: true } );\n *\n */\n\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/f7ec78508c6797e42f87a4390735bc2c650a1bfd/types/three/examples/jsm/exporters/STLExporter.d.ts\nexport interface STLExporterOptions {\n  binary?: boolean\n}\n\nclass STLExporter {\n  private binary\n\n  private output: string | DataView\n  private offset\n\n  private objects: { object3d: Object3D; geometry: PlaneGeometry }[]\n  private triangles\n\n  private vA\n  private vB\n  private vC\n  private cb\n  private ab\n  private normal\n\n  constructor() {\n    this.binary = false\n\n    this.output = ''\n    this.offset = 80 // skip header\n\n    this.objects = []\n    this.triangles = 0\n\n    this.vA = new Vector3()\n    this.vB = new Vector3()\n    this.vC = new Vector3()\n    this.cb = new Vector3()\n    this.ab = new Vector3()\n    this.normal = new Vector3()\n  }\n\n  public parse(scene: Object3D, options: STLExporterOptions): string | DataView {\n    this.binary = options.binary !== undefined ? options.binary : false\n\n    //\n\n    scene.traverse((object) => {\n      if (object instanceof Mesh && object.isMesh) {\n        const geometry = object.geometry\n\n        if (!geometry.isBufferGeometry) {\n          throw new Error('THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.')\n        }\n\n        const index = geometry.index\n        const positionAttribute = geometry.getAttribute('position')\n\n        this.triangles += index !== null ? index.count / 3 : positionAttribute.count / 3\n\n        this.objects.push({\n          object3d: object,\n          geometry: geometry,\n        })\n      }\n    })\n\n    if (this.binary) {\n      const bufferLength = this.triangles * 2 + this.triangles * 3 * 4 * 4 + 80 + 4\n      const arrayBuffer = new ArrayBuffer(bufferLength)\n      this.output = new DataView(arrayBuffer)\n      this.output.setUint32(this.offset, this.triangles, true)\n      this.offset += 4\n    } else {\n      this.output = ''\n      this.output += 'solid exported\\n'\n    }\n\n    for (let i = 0, il = this.objects.length; i < il; i++) {\n      const object = this.objects[i].object3d\n      const geometry = this.objects[i].geometry\n\n      const index = geometry.index\n      const positionAttribute = geometry.getAttribute('position')\n\n      if (object instanceof SkinnedMesh) {\n        if (index !== null) {\n          // indexed geometry\n\n          for (let j = 0; j < index.count; j += 3) {\n            const a = index.getX(j + 0)\n            const b = index.getX(j + 1)\n            const c = index.getX(j + 2)\n\n            this.writeFace(a, b, c, positionAttribute, object)\n          }\n        } else {\n          // non-indexed geometry\n\n          for (let j = 0; j < positionAttribute.count; j += 3) {\n            const a = j + 0\n            const b = j + 1\n            const c = j + 2\n\n            this.writeFace(a, b, c, positionAttribute, object)\n          }\n        }\n      }\n    }\n\n    if (!this.binary) {\n      this.output += 'endsolid exported\\n'\n    }\n\n    return this.output\n  }\n\n  private writeFace(\n    a: number,\n    b: number,\n    c: number,\n    positionAttribute: BufferAttribute | InterleavedBufferAttribute,\n    object: SkinnedMesh,\n  ): void {\n    this.vA.fromBufferAttribute(positionAttribute, a)\n    this.vB.fromBufferAttribute(positionAttribute, b)\n    this.vC.fromBufferAttribute(positionAttribute, c)\n\n    if (object.isSkinnedMesh) {\n      object.boneTransform(a, this.vA)\n      object.boneTransform(b, this.vB)\n      object.boneTransform(c, this.vC)\n    }\n\n    this.vA.applyMatrix4(object.matrixWorld)\n    this.vB.applyMatrix4(object.matrixWorld)\n    this.vC.applyMatrix4(object.matrixWorld)\n\n    this.writeNormal(this.vA, this.vB, this.vC)\n\n    this.writeVertex(this.vA)\n    this.writeVertex(this.vB)\n    this.writeVertex(this.vC)\n\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setUint16(this.offset, 0, true)\n      this.offset += 2\n    } else {\n      this.output += '\\t\\tendloop\\n'\n      this.output += '\\tendfacet\\n'\n    }\n  }\n\n  private writeNormal(vA: Vector3, vB: Vector3, vC: Vector3): void {\n    this.cb.subVectors(vC, vB)\n    this.ab.subVectors(vA, vB)\n    this.cb.cross(this.ab).normalize()\n\n    this.normal.copy(this.cb).normalize()\n\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, this.normal.x, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, this.normal.y, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, this.normal.z, true)\n      this.offset += 4\n    } else {\n      this.output += `\\tfacet normal ${this.normal.x} ${this.normal.y} ${this.normal.z}\\n`\n      this.output += '\\t\\touter loop\\n'\n    }\n  }\n\n  private writeVertex(vertex: Vector3): void {\n    if (this.binary && this.output instanceof DataView) {\n      this.output.setFloat32(this.offset, vertex.x, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, vertex.y, true)\n      this.offset += 4\n      this.output.setFloat32(this.offset, vertex.z, true)\n      this.offset += 4\n    } else {\n      this.output += `\\t\\t\\tvertex vertex.x vertex.y vertex.z\\n`\n    }\n  }\n}\n\nexport { STLExporter }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}